import { step } from 'mocha-steps';
import sinon from 'sinon';
import chai from 'chai';
import chaiSubset from 'chai-subset';
import chaiAsPromised from 'chai-as-promised';
import sinonChai from 'sinon-chai';
import { IntegrationTestHelpers, sleep } from '../testSupport';
import { InputStatus } from '../../src/types/fetch';
import { GatekeeperAPIStatus } from '../../src/types/gatekeeperApi';

chai.use(sinonChai);
chai.use(chaiSubset);
chai.use(chaiAsPromised);

const sandbox = sinon.createSandbox();

describe('GatewayClientCore refresh with expired document client sends integration tests', () => {
  let testHelpers: IntegrationTestHelpers;

  before(() => {
    testHelpers = new IntegrationTestHelpers(sandbox);
    testHelpers.stubRefreshPatchCall();
    // stub find token with an expired token
    testHelpers.stubFindToken({
      expiryTime: 1682891700, // old timestamp
    });
    // stub successful fetch calls with existing GK record
    testHelpers.stubSuccessfulFetchCalls({
      withExistingGatekeeperRecord: true,
      getResponsePayload: [GatekeeperAPIStatus.ISSUED_EXPIRED, { credentialExpired: true }],
    });
  });

  after(() => {
    testHelpers.cleanup();
    sandbox.restore();
  });

  afterEach(() => {
    testHelpers.expectFlowIdToBeSet('GWRC_refresh_');
  });

  step('1. Expect the Gatekeeper client to successfully initialize', async () => {
    testHelpers.initializeGatewayCore();
    // wait for GK and on-chain checks to complete
    await sleep(110);

    // And set the GKN Data such that the document will have expired
    testHelpers.updateGknData({
      status: InputStatus.COMPLETE,
      received: {
        id: 'validId',
        chains: {
          ethereum: {
            chainSpecificId: '123',
          },
        },
        constraints: {
          expiry: {
            maxRefreshPeriodSeconds: 1,
          },
        },
      },
    });
  });

  step('2. Expect gateway status to change to REFRESH_TOKEN_REQUIRED', async () => {
    testHelpers.expectCredentialExpired();
  });

  step('3. Emit a civic-pass event with the credential expired success action', async () => {
    await testHelpers.simulateCredentialExpiredSuccessEvent();
  });

  step('4. Expect gateway status to change to REFRESH_TOKEN_REQUIRED with expired flow parameter', async () => {
    testHelpers.expectRefreshTokenRequiredWithExpiredCredential();
  });

  step('5. Expect successful civic-sign public-key, did and POWO flows', async () => {
    await testHelpers.expectSuccessfulCivicSignProofFlow();
  });

  step('6. Simulate a successful client sending of transaction when presented to the user', async () => {
    await testHelpers.prepareSuccessfulHandleTransaction();
  });

  step('7. Simulate refresh action being triggered', async () => {
    await testHelpers.simulateSucessfulDataCollectionTriggeringGKRefreshRequest();
  });

  step('8. Wait for the GK refresh request to complete', async () => {
    await sleep(100);
  });

  step('9. expect state to be IN_REVIEW awaiting client-sends', () => {
    testHelpers.expectClientSendsInReview();
  });

  step('10. expect state to be IN_REVIEW awaitng on-chain confirmation', async () => {
    await sleep(20);
    testHelpers.expectClientSendsAwaitingConfirmation();
  });

  step(
    '11. OnChain listener fires with active token and gateway status and gateway token are updated to active',
    async () => {
      await testHelpers.simulateActiveOnChainToken();
      testHelpers.expectActiveToken();
    }
  );
});
