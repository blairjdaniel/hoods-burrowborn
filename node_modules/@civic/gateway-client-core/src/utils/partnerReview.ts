import { GatekeeperRecordResponse, PendingPayload } from '../types/gatekeeperApi';
import { GatewayInput } from '../types/gatewayCore';

export const getPendingRequestFromGatekeeperRecord = (
  gatekeeperRecord: GatewayInput<GatekeeperRecordResponse> | undefined
): PendingPayload | undefined =>
  (gatekeeperRecord?.received?.payload?.pending || gatekeeperRecord?.received?.pending) as PendingPayload;

/**
 * If the flow went IN_REVIEW (the 'partner approval' case), the Gatekeeper returns a 'pending' object containing the presentationRequestId.
 * That triggers the 'partner in review' state with associated UI.
 *
 * If the Gatekeeper accepted the request immediately (the 'no partner approval' case), the presentationRequestId will be at the top-level of the POST response.
 * We expose a single 'pendingRequests' object to the partner's dApp, containing whichever presentationRequestId is defined above.
 * Even though the request may not really be 'pending', we don't want to change the interface at this point as it would be a breaking change.
 * @param gatekeeperRecord
 * @returns
 */
export const getScopeRequestIdFromGatekeeperResponse = (
  gatekeeperRecord: GatewayInput<GatekeeperRecordResponse> | undefined
): string | undefined => {
  return (
    getPendingRequestFromGatekeeperRecord(gatekeeperRecord)?.presentationRequestId ||
    (gatekeeperRecord?.received?.payload?.presentationRequestId as string) ||
    (gatekeeperRecord?.received?.presentationRequestId as string)
  );
};
